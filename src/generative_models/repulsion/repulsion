
abstract type Thing end

struct Wall <: Thing
    # Dynamics
    d::Float64 # the distance from the center
    normal::SVector{2, Float64} # normal vector
    # Kinematics <none>
    # Graphcis <none>
end

struct Dot <: Thing
    # Dynamics
    radius::Float64

    # Kinematics
    pos::SVector{2, Float64}
    vel::SVector{2, Float64}

    # Graphics
    gstate::SMatrix{Float64} # graphics state
end


@with_kw struct RepulsionGM <: GenerativeModel

    # Epistemics
    n_dots::Int64 = 2


    # Dynamics
    dot_repulsion::Float64 = 80.0
    wall_repulsion::Float64 = 50.0
    distance::Float64 = 60.0
    rep_inertia::Float64 = 0.9

    # Kinematics
    dimensions::SVector{2, Float64} = SVector([100., 100.])
    vel::Float64 = 10.0 # base velocity

    # Graphics
    img_dims::SVector{2, Int64} = SVector([100, 100])
end

struct RepulsionState <: GMState
    walls::SVector{4, Wall}
    objects::SVector{Dot}
    distances::SMatrix{Float64}
end

function RepulsionState(gm::RepulsionGM, objects::SVector{Dot})
    walls = # define me
    RepulsionState(walls, objects)
end


# function load(::Type{RepulsionGM}, path::String)
#     RepulsionGM(;read_json(path)...)
# end

function step(gm::RepulsionGM, state::RepulsionState)::RepulsionState

    # Dynamics (computing forces)
    # for each dot compute forces
    @unpack n_dots = gm
    @unpack walls, objects = state
    new_dots = Vector{Dot}(undef, n_dots)
    @inbounds for i = 1:n_dots
        facc = zeros(2) # force accumalator
        dot = objects[i]
        for w in state.walls
            force!(facc, w, dot)
        end
        # TODO add interaction with other dots

        # kinematics: resolve forces to pos vel
        # also does graphical update
        new_dots[i] = apply_force(dot, facc)
    end

    RepulsionState(walls, SVector(new_dots))
end

"""Computes the force of A -> B"""
function force!(f::Vector{Float64}, ::Object, ::Object)
    error("Not implemented")
end
function force!(f::Vector{Float64}, w::Wall, d::Dot)
    # TODO
end
function force!(f::Vector{Float64}, a::Dot, b::Dot)
    # TODO
end

function apply_force(d::Dot, f::Vector{Float64})::Dot
    new_pos, new_vel = foo(dot, f)
    new_gstate = bar(dot, pos)
end

include("gen.jl")
